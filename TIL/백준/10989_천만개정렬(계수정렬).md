# 10989 - 천만 개 빠르게 정렬하기
  ### 1 문제
  > N개의 수가 주어졌을 때, 이를 오름차순으로 정렬하는 프로그램을 작성하시오
    
  ### 2. 입력
  > 첫째 줄에 수의 개수 **N(1 ≤ N ≤ 10,000,000)** 이 주어진다. 
  둘째 줄부터 N개의 줄에는 숫자가 주어진다. 이 수는 **10,000보다 작거나 같은 자연수**이다.
  
  ### 3. 출력
  > 첫째 줄부터 N개의 줄에 오름차순으로 정렬한 결과를 한 줄에 하나씩 출력한다.
  
# 접근
  - 입력 수의 최댓값이 10,000,000이므로 T(n) = O(nlogn) 알고리즘 사용 시 시간 초과.
  - 어떤 알고리즘을 사용해야 할 것인가 생각이 필요
  - 이때, 수의 범위가 **10,000보다 작거나 같은 자연수**로 정해져있으므로 **T(n) = O(n)인 '계수정렬'** 을 사용하면 된다.

# Code
  ```C++
  #include <iostream>
  #define NUM 10001

  using namespace std;

  int n;
  int a[NUM];

  int main(void) {
    scanf("%d", &n);
    for(int i = 0; i < n; i++) {
      int x;
      scanf("%d", &x);
      a[x]++;
    }
    for(int i = 0; i < NUM; i++) {
      while(a[i] != 0) {
        printf("%d\n", i);
        a[i]--;
      } 
    }
  }
  ```
  
 #### Why?
 ```C++
  int a[NUM];
 ```
 > 카운트할 배열을 전역 변수로 선언해주면 프로그램 시작과 동시에 배열의 모든 인덱스의 원소 값들은 '0'으로 초기화됨.
 따라서 굳이 for문으로 돌리면서 초기화하지 않아도 된다.

 ```C++
  for(int i = 0; i < n; i++) {
    int x;
    scanf("%d", &x);
    a[x]++;	//입력될 수의 조건이 자연수이기 때문에 
  }
 ```
 > 배열의 인덱스 a[0]을 버리고 a[1]부터 시작한다고 하면 그냥 입력받는 족족 그 수를 카운팅(**a[x]++**)하면 된다.  
 만약 배열 인덱스를 0부터 사용하려면 **a[x-1]++** 이렇게 선언한다. 만약 숫자 1을 받으면 a[0]이 카운팅됨.
